# C++ & Blueprint

虚幻引擎为您提供了多种编程游戏的选择：您可以使用C++，也可以使用虚幻的蓝图系统。C++和蓝图之间的一些区别是不言而喻的：使用C++，您是在使用一种通用的、基于文本的编程语言编写代码。蓝图更直观，也更适合高级游戏编程：你通过把代表事件、控制结构和函数调用的图形节点串起来来写代码，你通过编辑器内的对话框定义你的数据和接口，而不是用精确的语法写出定义。但是除了这些明显的区别之外，还有一些更细微的问题需要问自己，即如何在虚幻中制作游戏。这不仅仅是。"我应该使用C++还是应该使用蓝图"。事实上，那是一种错误的前提 - 虚幻的设计方式使得C++和蓝图是非常互补的。所以，一个更好的问题应该是。"在什么地方使用C++有意义，在什么地方使用Blueprints有意义？" 这就是我想在本视频中研究的问题。我们将讨论一些基本的设计原则，并了解一个项目通常是如何组织的，以便有效地利用两者。最后，我们将总结一下两者之间的一些区别。但在我们讨论这些之前，我想先谈谈蓝图和C++的一些共同点。如果我有一个自定义的角色类型，并且我想让它在游戏开始时产生另一个角色，这就是C++中可能出现的情况。而这里是蓝图中的同样内容。这两个片段可能看起来很不一样，但它们给了我们完全相同的结果。这给我们带来了一个重要的观点：你可以选择用C++实现这样一个例子，也可以使用Blueprints。但无论如何，你都在写代码。你可能在写代码时没有输入任何实际的语法，但你仍然在支配程序在运行时的行为。而且，几乎可以肯定的是，你将在一个既定的软件框架内工作，创建新的类，并定义这些类的行为和相互之间的互动。换句话说，你要处理的是软件设计。

因此，让我们来谈一谈设计。当你考虑一个复杂的软件时，比如一个视频游戏，纵向思考是有帮助的。通常，你的目标是实现一些复杂的、较高层次的功能。实际上，你实现这一目标的方法是将问题分解成可以在较低层次上实现的更基本的功能片段。如果你的游戏需要有一个超级酷的火箭发射器，发射不同种类的弹丸，这些弹丸飞来飞去，击中东西并引起爆炸，这很酷......但你不能凭空实现这些。你必须从某种程度上建立起来。所以你的游戏设计给了你一个定义，说明你的高级功能需要是什么样子的，而你所使用的引擎、框架或库给了你一个坚实的低级基础来建立。那么，作为程序员，我们的设计过程就是要填补这中间所有缺失的细节。因此，对于一个武器系统来说，我们可以从定义一个简单的继承层次结构开始，将我们的最终类连接到引擎提供的类型上。然后，我们要决定我们的每个自定义类应该负责什么，它们需要如何与我们游戏中的其他对象进行交互，以及它们应该利用哪些底层引擎功能。例如：基础武器类可以处理来自玩家的输入，管理弹药，决定是否开火，以及处理冷却时间。对于运行线迹或产生弹丸，我们可能会使用专门的子类：一个用于即时打击的武器，另一个用于弹丸武器。我们最终的、具体的武器类将从这里延伸。当然，继承并不是我们分解问题的唯一工具：我们还可以使用辅助对象或生成新的角色，我们还可以使用组件来增加可组合的功能片段。在每个层面上，我们都要使用引擎中实现的功能。为了瞄准和发射我们的武器，我们将使用来自玩家Pawn的输入和控制功能。为了检测我们是否击中了什么东西，我们将运行线条追踪或处理碰撞事件。为了让角色在被击中时做出反应，我们可能会使用内置的伤害系统。而且在很高的水平上，我们想控制所有这些东西的外观和声音，这意味着我们将结合不同的资产来利用引擎的渲染、动画、效果和音频系统。在虚幻中，我们可以用C++或蓝图来实现这些东西--无论哪种方式，我们都是以几乎相同的方式利用相同的底层引擎系统。

因此，对于我们最终设计中的一个单一功能，如武器，有一系列的问题需要回答，在不同的抽象层次上--从非常低级的，如 "我如何获得我需要的内存"，到非常高级的，如 "当持有我的玩家收集伤害力的时候，我应该发出什么颜色的紫色？" 这些低层次的问题通常属于引擎编程的范畴：所有的核心技术都允许我们建立一个游戏，而不必太在意我们在做什么样的游戏。当我们开始在核心技术的基础上解决我们正在制作的特定游戏的基本问题，并建立使我们的游戏可玩的系统时，我们就进入了游戏编程。然后，在这些系统的基础上，充实玩家的每一分钟的体验，我们可以把它广泛地称为脚本。脚**本的重点是更高层次的问题**，如：游戏的整体流程和进展；不同游戏对象之间的高层次互动；以及特定的、具体的游戏对象的外观、感觉和行为。这三大类可以帮助我们理解游戏项目中的大致分工，但它们都是概括性的。特别是，我们对 "脚本 "的定义是一个相当广泛的网。根据项目和团队的情况，可能会有一个实际的工作角色叫做 "脚本师"，或者不同的所谓 "脚本 "职责可能会在游戏设计师、关卡设计师、程序员、技术美工和其他人员之间分配。同样，我们所说的 "游戏编程 "和 "引擎编程 "可能涉及许多不同的子学科和工作角色，有很多潜在的重叠。重要的一点是，当我们谈论在某个层面上实现某项功能的工作时，我们通常可以在编程和脚本之间做出区分。通常，"编程 "是指解决低层次的问题，而 "脚本 "是指充实高层次的细节。如果您到目前为止同意我的观点，那么我们可以回到虚幻游戏编程的背景下讨论C++和Blueprints。

**C++是一种编程语言**，而**Blueprints是一种脚本系统**。C++自然更适合于实现低级别的游戏系统，而Blueprints自然更适合于定义高级别的行为和交互，以及整合资产和微调外观细节。对于一个典型的游戏开发项目，在一个传统的团队中，C++和蓝图通常是按照这些思路使用的。但是，您应该了解关于蓝图以及关于整个虚幻引擎的最基本的事情之一是，虚幻引擎不会为您划定这条界限。它不会预先规定某一类问题属于 "编程"(或 "脚本")的范畴，并要求您使用C++(或Blueprints)来解决这些问题。你可以自己划定这条线。你可以在不同的地方为不同的系统划定界限。你可以在原型设计时严重依赖蓝图，一旦你的设计变得更加清晰，就可以将界限转向C++。如果您是一个业余爱好者，或者是一个学生，或者是与一个非游戏开发背景的小团队一起工作，您可以在学习过程中倾向于使用Blueprints，而当您了解到如何以及何时使用C++时，您就可以逐渐转向C++。虚幻引擎被明确地设计为提供这种灵活性。没有单独的 "脚本API" - 无论您使用的是C++还是蓝图，您都在以同样的方式使用相同的底层引擎系统。C++和Blueprints被集成在一起，以实现轻松的互操作性，因此您的游戏可以轻松地在本地代码和脚本之间来回跳跃。而且，虚幻通过将UnrealHeaderTool代码生成绑定到UObject系统中来扩展C++，所以从Blueprints转移到用C++实现更高级别的功能比您想象的要容易。所以，如果有人问你，"C++和Blueprints哪个更好？" ...希望你知道为什么这是个有点傻的问题。当然，有一些实质性的差异可能会促使你选择其中之一，这取决于你正在从事的工作。

因此，让我们来谈谈其中的一些差异。在我们进一步讨论之前，我应该说明我们在这里讨论的是游戏编程。在开发虚幻项目的更大范围内，有很多情况下Blueprints并不是一个合适的选择，仅仅是因为Blueprints主要是为编写游戏代码而设计的。确切的界限可能有点模糊，但是举例来说，如果您在谈论向编辑器添加新的模式、开发独立的工具、集成外部库、添加自定义的渲染代码以及很多其他类似的事情......那么您将会使用C++或其他通用语言，而且通常是以一种不像高级游戏代码那样的方式进行的。我们在这段视频中谈论的 "游戏代码"，粗略地说是任何与UObject类有关的东西--基本上，在任何你看到使用了UCLASS、UPROPERTY和UFUNCTION宏的地方。因此，在C++和蓝图都是可行选择的情况下，有几个考虑因素可能会导致你使用其中一个而不是另一个。

一个经常被提到的因素是性能，我想从这里开始，因为它给了我们一个机会来看看引擎盖下面，看看事情在运行时是如何真正工作的。当你用C++写一个函数时，你最终会在一个.cpp文件中得到纯文本。当你用蓝图写一个函数时，你最终会得到一个事件图，由一堆节点组成，存储在一个蓝图资产中。当你从源码构建你的项目时，你的C++函数被编译成机器代码。它变成了处理器指令列表，直接在CPU上运行。你的蓝图函数也会被编译，但不是机器代码。蓝图函数是通过脚本编译器运行的，它将你的二维图形扁平化为脚本字节码的一维列表。这是你的函数的一种可移植的中间形式，引擎的脚本虚拟机在运行时执行。

我们在前面的武器例子中看到了这个函数：它在场景中运行一条线迹，如果它击中了一个角色，它就对该角色造成伤害。让我们来看看这个函数的两个版本--一个是从C++编译的，另一个是从蓝图编译的--看看我们看到了什么。这个函数需要两个参数：一个Transform，给我们提供跟踪的起点和方向，以及跟踪的最大距离。从我们的C++源代码编译出来的机器代码显示在左边。当我们进入函数的主体时，我们要做的第一件事就是找出轨迹的起始位置，这里我们看到了所产生的机器码。计算机的CPU通过将数据加载到寄存器中并运行对这些寄存器进行操作的指令来工作。我们使用局部变量和函数调用来编写我们的C++代码，但是编译器可以自由地优化这些细节，只要它能保证相同的最终结果。因此，我们的机器代码可能看起来很陌生--在这里，CPU根据以后需要使用这些值的方式，将一些数据加载到向量寄存器中。在右边，我们可以看到从我们的Blueprint函数中生成的脚本字节码，它作为我们原始事件图的翻译更容易被识别。如果我们继续计算跟踪的终点，我们可以看到一个更好的例子。在这里，C++编译器已经内联了所有相关的矢量数学：换句话说，我们最终不会调用GetUnitAxis，或矢量乘法或加法函数，这将涉及传递参数和跳转到代码的不同部分。当我们的函数被调用时，CPU就会直接完成所有这些数学运算，一气呵成。

我们的脚本字节码并不是那么低级的。脚本虚拟机有点像用软件实现的CPU，但它的工作只是跟踪脚本的执行情况，将表达式解析为数值，并跳转到执行具有正确参数的正确函数。当蓝图进行实际工作时，它们最终会调用由C++编译的本地函数。因此，如果我们需要在浮点变量的基础上构造一个向量，我们就在事件图中调用一个Make Vector。在产生的字节码中，脚本虚拟机准备了一个局部变量来保存结果值，然后它调用MakeVector函数。该函数需要三个值作为参数，所以它把我们的TraceDistance值和两个零一起推到脚本堆栈中。MakeVector是用C++实现的，所以它被编译为少量的CPU指令。但是由于MakeVector是一个可以调用蓝图的函数，UnrealHeaderTool生成了一个额外的函数，叫做execMakeVector，它在脚本VM和本地代码之间架起了桥梁。这就是脚本虚拟机实际跳转到的地方，如果我们把它扩展一下，我们可以看到它把我们的三个参数值从脚本堆栈中弹出，然后调用实际的MakeVector实现并把结果藏在脚本虚拟机提供的地址中。

当我们了解了这个函数的两个实现时，我们可以继续这个主题。当我们实际运行行迹跟踪时，两种实现最终都运行相同的本地函数，但左边的版本可以直接调用该函数，而右边的版本必须从脚本虚拟机传递一堆数据给本地辅助函数，然后再调用实际的行迹跟踪函数。当我们在命中结果中检查一个有效的Actor时，本地函数是非常直接的，而脚本函数则需要做更多工作。计算射击方向在本地函数中是完全内联的，但脚本函数则调用了一个辅助函数。但请记住：Context很重要。事实上，当涉及到优化时，Context就是一切。我们的脚本函数在脚本虚拟机中有一点开销，然后它跳转到execGetDirectionUnitVector，它被编译成这一点机器代码。该函数调用其他一些函数，然后最终调用实际的 GetDirectionUnitVector。因此，是的，蓝图函数导致更多的CPU指令被运行，所以它需要更多的时间做同样的工作，但如果这个蓝图代码每帧运行一次，而你在一帧中有16毫秒，那么这个开销绝对是微不足道的。但是，如果你有，比如说，1000个Actor每一帧都在运行这段代码，那么开销就会开始增加。Context很重要：你不能孤立地看这个例子并得出任何有用的结论。但是，一会儿会有更多关于这个问题的内容。如果我们击中了一个角色，我们通过应用点伤害来结束我们的函数，然后我们清理并返回。

那么，我们在性能方面学到了什么？好吧，如果你有两个相等的函数，一个用C++编写，另一个用Blueprints编写，C++函数会更快。C++函数可以在CPU层面上完全优化，而且它不会因为脚本执行而产生任何开销。顺便说一下，避免这种开销正是蓝图原生化的意义所在--如果你启用了原生化，那么脚本编译器就不会生成脚本字节码，而是吐出可以直接编译为机器码的C++源代码。生成的源代码并不是为了让人阅读或编辑的，但它会产生所有相同的本地函数调用，而不需要在脚本虚拟机上运行。

因此，如果我们正在创建一个游戏，我们可以对脚本开销最可能成为问题的地方做出合理的预测，并在这些地方倾向于使用C++。这可能包括各种低级系统，任何大规模操作数据的系统，任何在紧密循环中做大量工作的系统，以及任何可扩展到大量角色的系统。但是，如果你发现自己在权衡性能的取舍，请记住80/20规则适用于软件优化：80%的执行时间用于运行20%的代码。你可以使用剖析器来查看每一毫秒的帧的去向，而你关于优化什么的决定应该由这些数据来告知。如果你有一个用蓝图实现的系统，而你花了一周时间用C++重写整个系统以实现20倍的性能提升，但原来的蓝图系统只用了你整个CPU预算的一小部分，那么你并没有真正完成什么。或者，也许原来的实现确实占用了框架的很大一部分，但你只要用C++重写一个函数，而不是整个系统，就可以实现同样的节省。因此，C++的速度更快，但这种速度差异是否显著取决于上下文，如果有任何疑问，你应该用剖析器测量性能，并根据这些数据做出决定。当然，除了执行速度之外，还有一些原因使你可能想用C++编写系统的某些部分。

因此，让我们深入了解一下这些。游戏编程涉及到的不仅仅是编写函数实现。对于像虚幻这样的面向对象的框架，您通常将这些函数作为类的一部分来编写，所以在您开始实现一个类的函数之前，您首先需要定义该类。定义一个类意味着确定它应该负责什么，然后弄清楚它需要哪些属性和函数来准确地处理这个责任：不多也不少。它还涉及到弄清楚这些属性和函数中哪些应该对其他代码可见，作为类的公共接口的一部分，而哪些可以作为私有的实现细节隐藏起来。在C++中，你的类定义写在头文件中，而你的函数的实现通常写在.cpp文件中。一个蓝图资产大致相当于这两个文件。蓝图的父类，以及它的组件、属性和函数列表，构成了类的定义。事件图和其他函数图，正如我们已经看到的，包含了函数的实现。在这个层面上，C++和蓝图在如何允许你定义和实现新的类和其他类型方面是大致相当的。当我们开始讨论类型之间的依赖关系时，区别就出现了。每当你创建一个类、一个结构或一个枚举时，无论是在C++还是在编辑器中，你都在定义一个新的类型。在任何时候，如果一个类型需要了解另一个类型的情况，这就是你代码库中的一个依赖关系。在可能的情况下，最好确保依赖关系只是单向的。例如，如果你有一个发射导弹的武器，这意味着一个单向的依赖关系：武器必须知道导弹的情况才能产生导弹，但导弹不需要知道任何关于发射它的武器的情况。现在我们假设武器在任何时候都只允许有一枚导弹在飞行：我们必须等到现有的导弹爆炸后才能发射一枚新的导弹。我们可以通过让导弹调用武器上的一个函数来实现这一行为，让它知道它可以再次发射。但这将使我们的设计复杂化，因为它毫无理由地创造了一个双向的依赖关系。导弹不应该知道关于武器规则的任何事情：武器是否应该发射是武器的事情。导弹的唯一工作是爆炸。因此，为了保持这种单向的依赖性，我们可以给导弹一个委托，当它爆炸的时候就会被触发--在蓝图中，委托也被称为 "事件调度器"。导弹只需要发射委托，而不关心结果如何，武器可以将回调绑定到该委托上，以更新自己的内部状态。这样一来，武器和导弹就可以互不相干了，而且我们可以使这两个类之间的共享面积尽可能小。

随着项目越来越大，越来越复杂，管理这些依赖关系变得越来越重要，以确保代码库的不同部分之间的界限被清楚地定义。在C++中完成这种分离的一种方法是使用模块。你通常有一个主要的游戏模块，包含核心游戏类，如GameMode、PlayerController和Pawn。随着你的项目越来越复杂，你可能会把不同的功能和系统分割到它们自己的独立模块中。为了让一个模块中的类引用另一个模块中的类，这两个模块之间需要有明确的依赖关系，而且被引用的类或函数需要作为模块公共API的一部分导出。由于模块的依赖关系通常应该是严格的单向的，这导致了一种分层结构：在这个例子中，我们的武器模块位于我们的核心游戏模块下面。因此，我们可以让我们的Pawn产生一个武器，而Pawn可以从武器类中调用函数和访问数据，但武器永远不会被允许知道任何关于Pawn类的信息。这是我们强加给自己的一个限制：我们说，在设计上，武器模块中的类型不应该依赖于核心模块中的类型。如果我们试图编写违反既定设计的代码，那么构建系统将不允许这样做：我们将得到一个链接器错误，表明我们试图使用一个非明确依赖的模块的代码。虽然我们可能很想直接创建新的依赖关系，但这通常是一个信号，表明我们需要更仔细地思考我们正在做的事情，并且要么改变我们的代码以更好地适应既定的设计，要么重新评估那些最初的设计约束。

谨慎使用模块有很多具体的好处：它可以控制构建时间，在一个团队中，它可以更容易地确定哪些团队成员对代码库的不同部分拥有所有权，而且在理论上，它可以减轻你的认知负担：如果你在一个单一的模块中工作，那么你可以安全地忘记所有其他模块中的代码，除非你需要引入明确的、故意的依赖关系。当然，模块的界限是一把双刃剑。将你的代码库分割成独立的模块的主要好处是，当你添加新的类型或依赖关系时，它迫使你考虑你的设计。将你的代码库分割成独立的模块的关键缺点是，它迫使你在添加新的类型或依赖关系时考虑你的设计。

但是，当模块被明智地使用时，它们是保持大型项目有序进行的重要工具。你的项目代码库的总体设计可以写在你的模块边界上，你可以确信，如果你的项目成功地从源代码构建，那么这些边界就不会被违反。在蓝图中没有这样的界限。你可以把你项目中的所有蓝图看作是一个单一的概念模块，它位于每个实际的C++模块之上。你创建的任何蓝图都可以自由引用任何源模块中声明的任何类型，只要它是一个蓝图类型。对于高级别的编辑脚本工作来说，很难想象这些界限会成为不必要的障碍，所以这并不是什么坏处。但是，如果你在蓝图中编写核心游戏系统，那么你建立一个具有明确关注点分离的良好设计的重要性并不亚于C++。由于执行你的设计所规定的界限的工具较少，你可能不得不更加警惕，以防止你的代码库变得过于紧密地耦合起来。

蓝图是资产，所以你如何组织你的蓝图是一个资产组织的问题，这因项目和团队而异。值得指出的是，你可以使用编辑器的参考视图来获得一些非常有用的蓝图类型之间的依赖关系的一目了然的信息。因此，模块边界在蓝图中不是一个东西，将你的项目的C++源分成多个模块是完全可选的。但仍然需要注意的是，在C++和蓝图之间有一个概念上的模块边界，它形成了一种单向的依赖关系：你的蓝图类型可以依赖C++类型，但你的C++类型对蓝图类型一无所知。

假设我们纯粹在蓝图中工作，我们有一个自定义的Pawn类和一个武器类。我们需要在这两个类之间进行简单的单向交互：Pawn在BeginPlay时生成一个武器，如果玩家按下开火按钮，那么Pawn就会调用武器上的Fire函数。我们已经设置了我们的武器蓝图，所以当我们开火时，我们会运行一个线条跟踪，然后产生一些粒子效果。现在，假设我们想开始将一些核心类重构为C++，我们从Pawn开始。如果我们把Pawn类移到C++中，但把Weapon类留在Blueprints中定义，那么我们就必须面对这样一个事实：在C++模块的层面上，Weapon还不存在。我们仍然可以生成一个武器，这要感谢虚幻的反射系统：任何UObject类，不管它是在哪里定义的，都有一个与之相关的UClass对象，而且只要我们可以得到一个对武器的UClass的引用，我们就可以生成一个该类的Actor。

在这里，我们给了我们的Pawn两个属性：一个是我们想要生成一个实例的类，另一个将持有对该Actor本身的引用。在我们的构造函数中，我们可以解析对由我们的武器蓝图生成的类的一个引用。像这样直接引用C++中的蓝图资产，是一种比较脆弱的方法，但我们马上就会看到一些替代方案。现在，我们初始化我们的WeaponClass属性，以保持对蓝图生成的类的引用。然后，在BeginPlay中，我们可以生成一个该类的实例。但是注意：我们的武器属性的类型只是 "Actor"。武器类型是在蓝图中定义的，所以我们的C++Pawn对武器没有任何概念，除了它是某种Actor这一事实。这意味着我们不能调用武器的开火功能，因为该功能是在蓝图资产中定义的。从技术上讲，我们可以通过名称查找该函数并动态调用它，但至少可以说这是一件非常有问题的事情。但是，从技术上讲，如果我们删除我们的蓝图Pawn，转而使用我们新的C++Pawn类，一切仍然可以正常工作。真正的解决办法是将我们的武器类适当地重构为C++。但是我们的武器，就像我们目前实现的那样，也会产生粒子效果--这不是我们的C++Pawn实现真正需要关心的东西，而且我们更愿意在蓝图中实现这些外观效果。因此，我们最终用C++定义了一个基本的武器类，并通过武器蓝图对该类进行了进一步的专业化。

在我们的C++武器类中，我们实现了这个级别的相关功能：基本上只有开火功能，以及其他需要的数据或辅助功能。然后我们可以对我们的Pawn做一些改变。我们现在有一个在C++中定义的武器类，所以我们可以使用这个专门的类型而不是Actor。我们还想让WeaponClass属性可编辑，这样它就可以在蓝图中被重写。在.cpp文件中，我们不再需要直接引用蓝图。作为一个默认值，我们只需将WeaponClass初始化为我们的基础（C++）AWeapon类。Spawn没有什么不同，只是我们现在知道了所产生的角色的一个更精确的类型。最后，在我们的输入绑定中，我们可以正常调用Fire函数。我们现在有了一个有效的C++实现，通过Pawn的方式给我们一个可发射的武器。

但这只是基本的功能，对玩家来说没有视觉反馈：那么我们如何把我们原来的网格和粒子效果资产带回来？答案是将我们原来的蓝图重新parent到新的C++武器类中，这将给我们一个机会来看看C++基类和蓝图子类之间的基本互操作。但在这之前，让我们看看另一种方法，即把所有东西保持在C++中。就一会儿，让我们说服自己，"真正的 "程序员都是用C++做的。我们不想用蓝图来玷污自己，因为我们是 "真正的 "程序员。好吧，我们需要为我们的C++武器类添加一个网格组件，我们需要为我们的枪口闪光存储一个对ParticleSystem资产的引用。在构造函数中，我们需要为我们的武器获得对资产的引用。我们可以使用一个静态的FObjectFinder来确保这种资产查找只发生一次，即在游戏第一次启动时。对于每个资产，我们需要粘贴它的确切路径，我们可以通过在内容浏览器中找到资产并选择 "Copy Reference "来获得。所以现在我们的资产Reference 直接被硬编码到我们的源代码中。在某些情况下，这样做是很好的--特别是对于只有编辑器的资产引用，或者对于插件或引擎级的功能，特定的资产确实是不可或缺的。但是对于像这样的游戏对象，通常最好避免硬编码的资产引用。首先，这种方法在我们的C++武器类和它使用的任何资产之间建立了一个硬引用。这意味着，一旦我们的游戏启动并注册了武器类，它就必须立即加载这些资产，而这些资产将永久地留在内存中。

但是，就我们如何组织我们的项目而言，这也只是一个有问题的选择。我们使用哪些资产的问题是一个非常高级的问题，而我们的基础C++类被设计为处理稍低级别的功能。如果我们让我们的C++类在它已有的工作之外负责处理资产和外观效果，我们可能会赋予它过多的责任，使我们的设计变得混乱。如果我们在蓝图中处理资产，那么我们就会得到一个更自然的用户体验，有即时的视觉反馈来进行调整和微调，而且我们的资产引用是以一种允许资产流入和流出的方式为我们管理的，而且我们最终会得到一个更简洁的设计，在这里决定我们角色的外观和感觉的逻辑与决定其对游戏世界直接影响的逻辑是分开的。但是，为了完成我们的纯C++的例子，我们可以创建和配置一个StaticMeshComponent，确保我们手动输入正确的偏移量以匹配我们之前在编辑器中配置的内容，然后我们可以在武器发射时产生我们的枪口闪光粒子效果，使用的函数与我们从蓝图中调用的完全一样。这样就可以了，但让我们看看我们如何利用蓝图来实现这些外观细节。

首先，让我们来处理粒子效果。我们不希望我们的C++类关注具体的视觉效果；我们只希望它能够支配效果的生成。所以我们可以声明一个名为PlayFireEffects的函数，并添加BlueprintImplementableEvent指定器。这就给了我们一个蓝图子类可以响应的事件，而我们在C++中要做的就是调用这个函数来触发这个事件。接下来，让我们看一下网格组件。如果我们的C++代码需要对网格进行控制--例如，在运行时打开或关闭碰撞--那么将这个组件声明为我们C++类的一部分是完全合理的。我们可以撇开资产引用，让蓝图子类来处理完全自定义的网格组件。但在这种情况下，网格纯粹是为了展示，所以我们要把它从基类中完全剔除。所以现在，如果我们进入编辑器，我们可以打开我们原来的武器蓝图，它仍然只是一个Actor蓝图。我们可以删除我们重构到C++中的数据和功能，只留下我们的粒子效果和网格组件，然后我们可以重新parent这个蓝图，使它成为我们新的C++武器类的子类。我们所要做的就是将PlayFireEffects事件与我们的粒子效果挂钩，然后我们的武器就完成了。所以现在我们有一个蓝图，它扩展了我们的C++武器类。当蓝图被编译时，我们最终得到了一个新的武器类，它是由我们的蓝图生成的。现在唯一的问题是：我们如何使用我们新的BlueprintGeneratedClass而不是我们在C++中指定的基类？我们所要做的就是为我们的Pawn制作一个Blueprint子类，并改变WeaponClass属性的默认值。然后我们就可以使用这个新的Pawn类作为我们游戏模式的默认值。

这样一来，我们就保持了一个简洁的设计，其中的依赖关系只在一个方向上流动：我们有一个较高层次的蓝图层，它建立在较低层次的C++层之上，每个层都处理一组明确定义的职责，层与层之间的重叠最小。这是一个非常简单的例子，但我希望它能证明这个原则。这个模式就在这里--这种以结构化、互补的方式使用蓝图和C++的方法......这就是我前面提到的传统方法，中间的线画得很直。这是传统的、经典的模式，对于一个拥有必要技能的团队来说，制作一个适度复杂的游戏，这往往是最佳方法。但是，正如我们已经讨论过的，虚幻为您提供了大量的灵活性，所以如果您正在制作一个较小规模的游戏，或者您缺乏C++的经验，您不会被淘汰。作为一个例子，如果我们不想的话，我们不一定要把整个类型拉到C++中去。如果你做了一个扩展了 UBlueprintFunctionLibrary 的类，你可以添加静态的、可调用的 Blueprint 函数，让你在项目的任何地方充分利用本地代码。因此，我们也可以将我们的Pawn和Weapon类保留在Blueprints中，只是在需要时将个别函数重构为C++。

所以，我们已经对这些例子做了一些详细介绍。我希望你能更好地理解：当你的代码被编译和运行时，引擎盖下会发生什么；现实世界的项目通常是如何组织的，以确保清洁和可维护的设计；以及C++和蓝图对性能和项目组织的影响。现在我们对这些更细微的问题有了共识，让我们来总结一下C++和蓝图之间一些更直接的区别：在哪些情况下，一个比另一个更好--我敢说。**蓝图更适合于处理资产和视觉效果**。你的C++源代码只能盲目地猜测在运行时将会出现哪些资产，而蓝图就是资产。当你编辑蓝图时，你可以看到项目中的所有资产就在你的面前。你可以在蓝图中使用它们，并立即看到它们是如何使事物看起来和听起来的，并根据需要对它们进行调整。当你的C++代码直接引用资产时，这就在你编译的游戏模块和资产之间建立了一种依赖关系。如果资产发生变化，你需要回到构建管道的起点，手动更新你的源代码，并重新编译。当你的蓝图引用一个资产时，这只是创建了一个资产到资产的依赖关系，引擎可以很自然地处理。**当涉及到脚本化序列时**，蓝图也有明显的优势。如果你在一个事件图中工作，而不是在一个函数图中工作，你可以充分利用事件和潜在的函数，以一种非常直接和直观的方式编写异步代码。如果我想让一个角色移动到某个地方，然后等待3秒钟，然后等待一扇门打开，每半秒检查一次，然后向敌人射击，直到敌人死亡，然后继续通过门......在蓝图中，我们基本上可以用一个直接的、独立的图来直接表达事件的顺序。从技术上讲，你可以在C++中做同样的事情，但你只能使用定时器和回调，这样的表达方式要差得多，而且显然更难调整和迭代。像这样的脚本事件通常是用Sequencer来实现的，它允许你使用事件轨迹，以便与你的关卡蓝图和Actor身上的蓝图可调用功能轻松整合。事件图还允许你使用时间线组件，这是一种非常方便的方法，可以让属性或效果随时间变化。你可以在C++中做类似的事情，但这通常涉及到对曲线资产的引用和取样......或者想出一个方程式，让你直接在代码中表达你的动画。**蓝图允许你快速测试和迭代**。整个蓝图创作的经验是在运行时，在编辑器中进行的，不需要离线构建过程。你可以看到一些东西是如何运行的，做一个快速的改变，然后直接返回到编辑器中播放。你可以在游戏运行时探究你的事件图，以检查数值和调试你的脚本执行。你可以在游戏运行时暂停游戏，尽情地调整属性。蓝图可以被更多的用户使用。跳进编辑器，玩玩蓝图，对于C++经验有限的人来说是一个很好的起点。即使你自己是一个C++向导，也不是每个人都是。当艺术家、设计师和其他团队成员能够安全、轻松地对更广泛的问题集做出贡献时，你的项目和你的开发周期会因此而变得更好。你仍然需要技能和质量控制，就像你可以写出好的或坏的C++，你也可以写出好的或坏的蓝图。但错误的C++代码往往比错误的Blueprints对你的工作流程造成更大的损害。**Blueprints通常不会导致直接的崩溃**。而且蓝图是可以被发现的。所有的东西都是集成的：你可以使用的所有类型和功能都在蓝图编辑器中为你列出，所以你可以在开始阅读文档之前了解到有哪些东西可以利用。快速迭代和视觉反馈使你可以很容易地测试事物，并弄清楚它们是如何交互工作的。如果您是虚幻的新手，即使您有C++的经验，从Blueprints开始玩也不是一个坏主意。您使用Blueprints学到的东西往往可以直接转移到C++中。

那么C++呢？正如我们所看到的，**C++可以给你带来最大的运行时性能**。**你的C++代码可以在编译时针对它要运行的平台进行完全优化**。当你的源代码在一个完全优化的发布版本中被编译成机器代码时，它就变成了裸机，没有任何多余的东西：没有开销。尽管蓝图原生化在某些情况下可以产生很大的不同，但它仍然给你的项目的构建过程增加了一些相当古怪的复杂性，而这是你必须权衡的成本。无论如何，C++是真正对你的项目至关重要的代码的最佳位置。任何需要在C++和蓝图中被引用的类型都应该在适当的C++模块中声明。而且，C++也只是......稳固。你的C++源代码只是纯文本：它很简单，很直接。除了其他更基本的C++代码和库，它不依赖于任何东西。它是用一种高度标准化、支持性极强的通用语言编写的。它是毫不含糊的。它的意义或行为或正确性不会因为任何原因而改变，除了升级你的引擎版本或编译器版本。因此，C**++是任何对你的项目至关重要的代码的理想场所**：**任何你需要坚如磐石，并且易于阅读、理解、扩展和维护的代码**。C++还暴露了更广泛的引擎功能--这种东西往往对那种基本代码很有用。你可以充分利用日志系统，用有用的诊断输出来检测你的代码。你可以添加断言来强制执行不变量，并确保你的代码在你期望的条件下运行，当事情出错时，会有有用的错误信息提示。你可以定义自定义控制台变量，让你在运行时通过调整控制台的值来实时控制你的游戏行为。你可以添加自定义的统计类别来获取详细的分析信息，让你衡量游戏中各个系统和功能的性能影响。你可以对你的类型和接口的暴露方式进行更多的控制，包括对C++代码库的其他部分、蓝图脚本以及编辑器中的用户。你可以更精确地控制网络复制，使用优先级和相关度的自定义规则，你可以利用复制图系统等高级功能。你可以创建原始的TCP和UDP套接字来发送和接收较低层次的数据，你可以使用Http和Json模块来与网络API通信。你可以定义序列化的规则，以规定结构和其他类型如何写入磁盘或压缩用于复制。你可以钩住在保存和加载过程中发生的较低级别的事件，允许你在加载时操作数据并促进向后兼容。你可以添加编辑器专用的代码和数据，这些代码和数据是特定于编辑器或烹饪过程的，并被编入非编辑器的构建中。你可以添加编辑器模块，允许你用新的UI元素、新的资产编辑器窗口和导入器以及新的编辑器模式和视口工具来扩展编辑器。你可以钩住广泛的引擎和编辑器委托，在不同的事件发生时运行自定义代码。而且，从一个C++模块，无论是作为你的项目的一部分还是在一个插件中，你都可以集成第三方库。如果你想把一个C或C++库纳入你的游戏，你可以为你支持的平台建立一个静态或共享库，更新你的模块构建规则以包括它并与它链接，然后在你的项目或插件中使用该代码。这是C++最明显的优势之一，也是最强大的优势之一：只要是计算机能做的事情，你都可以让你的游戏做。最后，从工作流程的角度来看。与蓝图不同，**C++可以非常容易地进行差异和合并**。对于小项目来说，这可能不是一个很大的问题，但在一个较大的团队中，这就变得相当重要了。在你向项目的版本控制系统提交修改之前，你希望能够对你所修改的文件进行比较，这样你就能准确地审查你所修改的内容。或者你可能会发现自己在查看修改历史，以了解一个系统是如何随着时间的推移而形成和变化的，或者追踪一个错误。在这些情况下，你希望能够快速地看到文件在每次修订时的变化。普通的源代码是纯文本，对其进行差分是很容易的。有很多工具可以向你展示一个文本文件的两个不同版本之间的差异的逐行细分。合并是纯文本的另一个主要好处。两个人可以同时在同一个源文件上工作，而版本控制系统可以自动将他们的修改合并在一起。可能会有合并冲突，在这种情况下，有些东西不能自动解决，而必须由人介入，但对C++源代码的大多数修改都可以自动合并。但**蓝图是二进制文件**，关键是，它们依赖于你的项目的编辑器构建。也就是说，为了查看它们，或编辑它们，或使它们具有任何意义，你必须启动编辑器并加载你的项目。这使得差异和合并蓝图的难度大大增加。幸运的是，编辑器包含了一个内置的工具，用于对蓝图进行比较，而且在简单的情况下，它的效果很好。如果你只是想在提交之前审查你的修改，你可以在编辑器中非常容易地做到这一点。不过，如果你针对旧的修订版进行比较，而这些修订版所依赖的类型在当前的构建中已不存在，那么你就会遇到麻烦。在蓝图上做代码审查在技术上是可行的，但与查看源代码的变化相比，这是一个更麻烦的过程。对于合并。蓝图并不是真正的可合并的--当你需要解决蓝图上的冲突变化时，有一个内置的合并工具可以派上用场，但对蓝图资产的任何合并都需要人工干预，即使没有冲突的变化。合并工具是相当有限的：它基本上向你显示相关的变化，并让你选择一个版本或另一个版本来接受--除此之外，你还需要手动修复。因此，传统的观点是，你应该像对待其他资产一样对待蓝图，检查文件意味着你要锁定它供你独家使用。归根结底，这些都是可以接受的权衡，但考虑到蓝图是多么强大和有用，我确实认为，当涉及到如何在协作工作流程中使用它们时，它们带有这些注意事项是很可惜的。对我来说，这是我在UE4中从UnrealScript转向Blueprints的过程中非常明确地不喜欢的一件事。

最后，这给我们带来了最后一个因素：个人偏好。有偏好是可以的。我认为Blueprints很好，但是有时我仍然怀念UnrealScript，因为当你已经清楚地知道你要输入什么时，通过用鼠标拖动小线来写代码会开始感到非常麻烦。不喜欢某些类型的工作而喜欢其他的工作是可以的。我们都有自己的偏好。但我们必须保持一定的自我意识，以确保我们不会让个人偏好影响我们的判断。制作游戏的工作很复杂，而且是一个团队的努力。当你做出影响整个项目和整个团队的决定时--比如如何平衡C++和蓝图--你必须权衡一系列更重要的因素。什么对性能最好？什么与项目的整体设计最匹配？什么是最容易维护的？根据我们的时间表和预算限制，以及我们团队的组成，什么能让我们完成工作？通常，在 "我不喜欢输入格式良好的C++"或 "我不喜欢把节点挂在一起 "成为一个相关因素之前，你就会得出一个答案。但是，如果其他方面都一样，而且任何一种选择都是有效的--或者如果你只是把做游戏作为一种爱好--那么通过各种手段，你应该采取你认为更愉快的方法。毕竟，如果人们有一点点乐趣，他们往往会做得更好。但无论你的背景或经验水平如何，我都会鼓励你尝试使用C++和蓝图，并让你的脚步变得湿润。如果你花时间去了解它们各自的优势所在，我想你会发现它们都非常有趣。

所以你有了它--我关于虚幻中的蓝图和C++的宣言。谢谢您的坚持，我希望您能学到一些新的东西。特别感谢那些帮助我实现这个视频的赞助人 这是我的一个定期的副业，我很感激我能够花时间，涵盖我觉得有资格谈论的话题，并投入必要的工作，最终得到一个我可以引以为豪的视频。你在Patreon上的支持，以及你在评论中的反馈和你愿意在其他地方分享这段视频，对于让我做到这一点至关重要。所以......谢谢你 