# 物理同步

## 自主代理端

### 客户端预测机制

#### why 

快速响应

#### how

客户端接收到玩家输入后，立即模拟物理驱动载具运动，除此之外，还要将本帧用于模拟的输入数据以及模拟结果保存在Buffer中，并发送给服务器，接下来继续重复上述步骤。服务器接收到客户端的输入后以相同的输入进行物理模拟并驱动载具运动，完成之后服务器会对比客户端的模拟结果与服务端的模拟结果，如果对比后的结果相差过大，则发送矫正的命令，否则发送确认的命令。这个流程中客户端总是要领先服务器几帧。客户端在收到确定的命令后，删除buffer中这个帧之前的所有保存数据，并继续当前模拟。如果收到矫正的命令后则需要直接将服务器的模拟结果设置给载具，并从该帧开始应用buffer中缓存的输入数据重新模拟到当前帧。

物理引擎的不确定性，网络延迟等因素的存在，会出现预测错误的现象，需要服务器验证。为了尽可能保证服务端和客户端一致，采用

- 固定帧率（FixedUpdate）

##### 客户端

除了主角驾驶的载具，其他载具都是运动学的。

- 维护预测数据的Buffer，包括帧号，输入，模拟结果，主要是刚体的位置旋转速度角速度等物理量
- 通过代码调用Physics引擎的Simulate，以便进行重播和动态调整

服务端

所有载具都是物理的

- 保存一个小的，未模拟输入的缓冲区，当缓冲区为空后，只能通过玩家上一帧的输入数据去模拟，并向客户端发送快速模拟的指令，客户端会动态调整自己的物理模拟速度，以向服务端发送更多输入数据，当缓冲区恢复正常时，服务端向客户端发送停止调整的命令，以便客户端将每帧物理模拟的频率调慢
- 滑动窗口

## 模拟代理端

#### 内插值

基于收到的snapshot，用Exponential的smooth算法平滑的移动载具。特点是精确

#### 外插值

基于收到的snapshot，预测当前或者未来某时刻载具的位置，为了更即时的表现碰撞

**导航推测算法**（**Projective Velocity Blending**）

先对速度做混合，求出一个新的速度，然后拿原先的速度和混合出的速度，各自计算出一个位置，然后在这两者之间插值。

#### 碰撞时的处理（**Physics Simulation Blending**）

在碰撞发生时候让本地的物理引擎去模拟出一个真实的碰撞效果，一个是基于snapshot用同步算法计算出来的轨迹，另一个是本地物理模拟出来的轨迹。Physics Simulation Blending就是将这两条轨迹（包含位置和速度）进行混合，其中混合系数随时间变化。在碰撞发生的一瞬间，系数为1，replica的运动完全受物理模拟控制，从而表现出真实的碰撞效果。随着时间的推移，系数逐渐降低为0，replica的运动完全受到同步算法控制。